# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022 Jeff Forcier
# This file is distributed under the same license as the Invoke package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Invoke \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-28 10:29+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.0\n"

#: ../../faq.rst:3
msgid "Frequently asked questions"
msgstr ""

#: ../../faq.rst:7
msgid "General project questions"
msgstr ""

#: ../../faq.rst:12
msgid "Why was Invoke split off from the `Fabric <http://fabfile.org>`_ project?"
msgstr ""

#: ../../faq.rst:14
msgid ""
"Fabric (1.x and earlier) was a hybrid project implementing two feature "
"sets: task execution (organization of task functions, execution of them "
"via CLI, and local shell commands) and high level SSH actions "
"(organization of servers/hosts, remote shell commands, and file "
"transfer)."
msgstr ""

#: ../../faq.rst:19
msgid ""
"For use cases requiring both feature sets, this arrangement worked well. "
"However, over time it became clear many users only needed one or the "
"other, with local-only users resenting heavy SSH/crypto install "
"requirements, and remote-focused users struggling with API limitations "
"caused by the hybrid codebase."
msgstr ""

#: ../../faq.rst:25
msgid ""
"When planning Fabric 2.x, having the \"local\" feature set as a "
"standalone library made sense, and it seemed plausible to design the SSH "
"component as a separate layer above. Thus, Invoke was created to focus "
"exclusively on local and abstract concerns, leaving Fabric 2.x concerned "
"only with servers and network commands."
msgstr ""

#: ../../faq.rst:31
msgid ""
"Fabric 2 leverages many parts of Invoke's API, and allows (but does not "
"require!) use of Invoke's CLI features, allowing multiple use cases "
"(build tool, high level SSH lib, hybrid build/orchestration tool) to "
"coexist without negatively impacting each other."
msgstr ""

#: ../../faq.rst:38
msgid "Defining/executing tasks"
msgstr ""

#: ../../faq.rst:43
msgid "My task's first argument isn't showing up in ``--help``!"
msgstr ""

#: ../../faq.rst:45
msgid ""
"This problem pops up if you forget to define an initial context argument "
"for your task."
msgstr ""

#: ../../faq.rst:48
msgid "For example, can you spot the problem in this sample task file?"
msgstr ""

#: ../../faq.rst:62
msgid ""
"This task file doesn't cause obvious errors when sanity-checking it with "
"``inv --list`` or ``inv --help``. However, ``clean`` forgot to set aside "
"its first argument for the context - so Invoke is treating ``what`` as "
"the context argument! This means it doesn't show up in help output or "
"other command-line parsing stages."
msgstr ""

#: ../../faq.rst:69
msgid "The command line says my task's first argument is invalid!"
msgstr ""

#: ../../faq.rst:71
msgid "See :ref:`bad-first-arg` - it's probably the same issue."
msgstr ""

#: ../../faq.rst:75
msgid "Running local shell commands (``run``)"
msgstr ""

#: ../../faq.rst:80
msgid ""
"Why is my command behaving differently under Invoke versus being run by "
"hand?"
msgstr ""

#: ../../faq.rst:82
#, python-format
msgid ""
"99% of the time, adding ``pty=True`` to your ``run`` call will make "
"things work as you were expecting. Read on for why this is (and why "
"``pty=True`` is not the default)."
msgstr ""

#: ../../faq.rst:86
msgid ""
"Command-line programs often change behavior depending on whether a "
"controlling terminal is present; a common example is the use or disuse of"
" colored output. When the recipient of your output is a human at a "
"terminal, you may want to use color, tailor line length to match terminal"
" width, etc."
msgstr ""

#: ../../faq.rst:91
msgid ""
"Conversely, when your output is being sent to another program (shell "
"pipe, CI server, file, etc) color escape codes and other terminal-"
"specific behaviors can result in unwanted garbage."
msgstr ""

#: ../../faq.rst:95
msgid ""
"Invoke's use cases span both of the above - sometimes you only want data "
"displayed directly, sometimes you only want to capture it as a string; "
"often you want both. Because of this, there is no \"correct\" default "
"behavior re: use of a pseudo-terminal - some large chunk of use cases "
"will be inconvenienced either way."
msgstr ""

#: ../../faq.rst:101
msgid ""
"For use cases which don't care, direct invocation without a pseudo-"
"terminal is faster & cleaner, so it is the default."
msgstr ""

#: ../../faq.rst:105
msgid ""
"Calling Python or Python scripts prints all the output at the end of the "
"run!"
msgstr ""

#: ../../faq.rst:108
msgid "This is typically a problem under Python 3 only."
msgstr ""

#: ../../faq.rst:110
msgid ""
"The symptom is easy to spot - you're running a command that takes a few "
"seconds or more to execute, it usually prints lines of text as it goes, "
"but via `~invoke.run` nothing appears to happen at first, and then all "
"the output prints once it's done executing."
msgstr ""

#: ../../faq.rst:115
msgid ""
"This is usually due to Python - the \"inner\" Python executable you're "
"invoking, not the one Invoke is running under - performing unwanted "
"buffering of its output streams. It does this when it thinks it's being "
"called in a non-interactive fashion."
msgstr ""

#: ../../faq.rst:120
msgid ""
"The fix is to force Invoke to run the command in a pseudoterminal by "
"saying ``pty=True`` (e.g. ``run(\"python foo\", pty=True)``)."
msgstr ""

#: ../../faq.rst:123
msgid ""
"Alternately, since both Invoke and the inner command are Python, you "
"could try loading the inner Python module directly in your Invoke-using "
"code, and call whichever methods its command-line stub is using - instead"
" of using `~invoke.run`. This can often have other benefits too."
msgstr ""

#: ../../faq.rst:131
msgid "Why do I sometimes see ``err: stdin: is not a tty``?"
msgstr ""

#: ../../faq.rst:133
msgid ""
"See :ref:`program-behavior-ptys` - the same root cause (lack of a PTY by "
"default) is probably what's going on. In some cases (such as via the "
"Fabric library) it's happening because a shell's login files are calling "
"programs that require a PTY (e.g. ``biff`` or ``mesg``) so make sure to "
"look there if the actual foreground command doesn't seem at fault."
msgstr ""

#: ../../faq.rst:140
msgid "Everything just exits silently after I run a command!"
msgstr ""

#: ../../faq.rst:142
msgid ""
"Double check the command's exit code! By default, receiving nonzero exit "
"codes at the end of a `~invoke.run` call will result in Invoke halting "
"execution & exiting with that same code. Some programs (pylint, Nagios "
"check scripts, etc) use exit codes to indicate non-fatal status, which "
"can be confusing."
msgstr ""

#: ../../faq.rst:147
msgid ""
"The solution here is to add ``warn=True`` to your `~invoke.run` call, "
"which disables the automatic exit behavior. Then you can check the "
"result's ``.exited`` attribute by hand to determine if it truly "
"succeeded."
msgstr ""

#: ../../faq.rst:152
msgid "The auto-responder functionality isn't working for my password prompts!"
msgstr ""

#: ../../faq.rst:154
msgid ""
"Some programs write password prompts or other output *directly* to the "
"local terminal (the operating-system-level TTY device), bypassing the "
"usual stdout/stderr streams. For example, this is exactly what `the "
"stdlib's getpass module <getpass.getpass>` does, if you're calling a "
"program that happens to be written in Python."
msgstr ""

#: ../../faq.rst:160
msgid ""
"When this happens, we're powerless, because all we get to see is the "
"subprocess' regular output streams. Thankfully, the solution is usually "
"easy: just add ``pty=True`` to your `~invoke.run` call. Forcing use of an"
" explicit pseudo-terminal usually tricks these kinds of programs into "
"writing prompts to stderr."
msgstr ""

#: ../../faq.rst:167
msgid ""
"I'm getting ``IOError: Inappropriate ioctl for device`` when I run "
"commands!"
msgstr ""

#: ../../faq.rst:169
msgid ""
"This error typically means some code in your project or its dependencies "
"has replaced one of the process streams (``sys.stdin``, ``sys.stdout`` or"
" ``sys.stderr``) with an object that isn't actually hooked up to a "
"terminal, but which pretends that it is. For example, test runners or "
"build systems often do this."
msgstr ""

#: ../../faq.rst:175
#, python-format
msgid ""
"99% of the time, this pops up for stdin only, in which case you may be "
"able to work around it by specifying ``in_stream=False`` to `~invoke.run`"
" (note: ``False``, **not** ``None``!)"
msgstr ""

#: ../../faq.rst:180
msgid "Gory details"
msgstr ""

#: ../../faq.rst:182
msgid ""
"Technically, what's happened is that the object handed to Invoke's "
"command executor as e.g. ``run('command', in_stream=xxx)`` (or "
"``out_stream`` or etc; and these all default to the ``sys`` members "
"listed above) implements a ``fileno`` method that is not returning the ID"
" of a real terminal file descriptor. Breaking the contract in this way is"
" what's leading Invoke to do things the OS doesn't like."
msgstr ""

#: ../../faq.rst:189
msgid ""
"We're always trying to make this detection smarter; if upgrading to the "
"latest version of Invoke doesn't fix the problem for you, please submit a"
" bug report including details about the values and types of "
"``sys.stdin/stdout/stderr``. Hopefully we'll find another heuristic we "
"can use!"
msgstr ""

