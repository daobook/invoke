# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022 Jeff Forcier
# This file is distributed under the same license as the Invoke package.
# xinetzone <735613050@qq.com>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Invoke \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-27 16:23+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.0\n"

#: ../../concepts/namespaces.rst:5
msgid "Constructing namespaces"
msgstr "构建名称空间"

#: ../../concepts/namespaces.rst:7
msgid ""
"The :doc:`base case </getting-started>` of loading a single module of "
"tasks works fine initially, but advanced users typically need more "
"organization, such as separating tasks into a tree of nested namespaces."
msgstr ""
"加载单个任务模块的 :doc:`base case </getting-started>` 在一开始工作得很好，"
"但高级用户通常需要更多的组织，比如将任务分割成嵌套命名空间树。"

#: ../../concepts/namespaces.rst:11
msgid ""
"The `.Collection` class provides an API for organizing tasks (and "
":ref:`their configuration <collection-configuration>`) into a tree-like "
"structure. When referenced by strings (e.g. on the CLI or in pre/post "
"hooks) tasks in nested namespaces use a dot-separated syntax, e.g. "
"``docs.build``."
msgstr ""
"`.Collection` 类提供了 API 来组织任务（和 :ref:`their configuration <collection-configuration>`）成一个树状结构。"
"当被字符串引用时（例如在 CLI 或 pre/post 钩子中）嵌套命名空间中的任务使用点分隔语法，例如 ``docs.build``。"

#: ../../concepts/namespaces.rst:16
msgid ""
"In this section, we show how building namespaces with this API is "
"flexible but also allows following Python package layouts with minimal "
"boilerplate."
msgstr ""
"在本节中，我们将展示如何使用这个 API 灵活地构建名称空间，同时还允许使用最少的样板文件遵循 Python 包布局。"

#: ../../concepts/namespaces.rst:21
msgid "Starting out"
msgstr "开始"

#: ../../concepts/namespaces.rst:23
msgid ""
"One unnamed ``Collection`` is always the namespace root; in the implicit "
"base case, Invoke creates one for you from the tasks in your tasks "
"module.  Create your own, named ``namespace`` or ``ns``, to set up an "
"explicit namespace (i.e. to skip the default \"pull in all Task objects\""
" behavior)::"
msgstr ""
"未命名的 ``Collection`` 总是命名空间根；在隐式的基本情况下，Invoke 从 tasks 模块中的任务中为你创建一个。"
"创建你自己的命名为 ``namespace`` 或 ``ns`` 的命名空间，以建立显式的命名空间"
"（即跳过默认的 \"pull in all Task objects\" 行为）::"

#: ../../concepts/namespaces.rst:33
msgid ""
"Add tasks with `.Collection.add_task`. `~.Collection.add_task` can take "
"an `.Task` object, such as those generated by the `.task` decorator::"
msgstr ""
"使用 `.Collection.add_task` 添加任务。"
"`~.Collection.add_task` 可以接受 `.Task` 对象，例如由 `.task` 装饰器生成的 ::"

#: ../../concepts/namespaces.rst:45
msgid "Our available tasks list now looks like this::"
msgstr "我们的可用任务列表现在看起来像这样 ::"

#: ../../concepts/namespaces.rst:54
msgid "Naming your tasks"
msgstr "命名你的任务"

#: ../../concepts/namespaces.rst:56
msgid ""
"By default, a task's function name is used as its namespace identifier, "
"but you may override this by giving a ``name`` argument to either `@task "
"<.task>` (i.e. at definition time) or `.Collection.add_task` (i.e. at "
"binding/attachment time)."
msgstr ""
""默认情况下，任务的函数名被用作它的命名空间标识符，但是你可以通过给 `@task <.task>` ``name`` 参数来覆盖它"
"（例如，在定义的时候）或者 `.Collection.add_task` （即在 binding/attachment 时）。"

#: ../../concepts/namespaces.rst:61
msgid ""
"For example, say you have a variable name collision in your tasks module "
"-- perhaps you want to expose a ``dir`` task, which shadows a Python "
"builtin. Naming your function itself ``dir`` is a bad idea, but you can "
"name the function something like ``dir_`` and then tell ``@task`` the "
"\"real\" name::"
msgstr ""
"例如，假设你在你的任务模块中有一个变量名冲突——也许你想暴露 ``dir`` 任务，它遮蔽了 Python 内置。"
"将函数本身命名为 ``dir`` 是个坏主意，但你可以将函数命名为 ``dir_``，然后告诉  ``@task`` 这个 \"real\" 名字::"

#: ../../concepts/namespaces.rst:70
msgid ""
"On the other side, you might have obtained a task object that doesn't fit"
" with the names you want in your namespace, and can rename it at "
"attachment time. Maybe we want to rename our ``release`` task to be "
"called ``deploy`` instead::"
msgstr ""
"另一方面，您可能已经获得了任务对象，该对象不符合您希望在名称空间中的名称，可以在附加时重命名它。"
"也许我们需要将 ``release`` 任务重命名为 ``deploy`` ::"

#: ../../concepts/namespaces.rst:77
msgid "The result::"
msgstr "结果是 ::"

#: ../../concepts/namespaces.rst:85
msgid ""
"The ``name`` kwarg is the 2nd argument to `~.Collection.add_task`, so "
"those in a hurry can phrase it as::"
msgstr ""
"``name`` kwarg 是 `~.Collection.add_task` 的第二个参数，"
"所以那些匆忙的人可以把它写成 ::"

#: ../../concepts/namespaces.rst:91
msgid "Aliases"
msgstr "别名"

#: ../../concepts/namespaces.rst:93
msgid ""
"Tasks may have additional names or aliases, given as the ``aliases`` "
"keyword argument; these are appended to, instead of replacing, any "
"implicit or explicit ``name`` value::"
msgstr ""
"任务可能有额外的名称或别名，给出 ``aliases`` 关键字参数；"
"它们被附加到任何隐式或显式的 ``name`` 值，而不是替换 ::"

#: ../../concepts/namespaces.rst:99
msgid "Result, with three names for the same task::"
msgstr "结果，同一个任务有三个名称 ::"

#: ../../concepts/namespaces.rst:109
msgid ""
"The convenience decorator `@task <.task>` is another method of setting "
"aliases (e.g. ``@task(aliases=('foo', 'bar'))``, and is useful for "
"ensuring a given task always has some aliases set no matter how it's "
"added to a namespace."
msgstr ""
"便捷的装饰器 `@task <.task>` 是另一种设置别名的方法（例如 ``@task(aliases=('foo', 'bar'))``，"
"这对于确保给定的任务总是有一些别名设置非常有用，无论它是如何添加到命名空间的。"

#: ../../concepts/namespaces.rst:117
msgid "Dashes vs underscores"
msgstr "破折号和下划线"

#: ../../concepts/namespaces.rst:119
msgid ""
"In the common case of functions-as-tasks, you'll often find yourself "
"writing task names that contain underscores::"
msgstr ""
"在函数即任务的常见情况下，你经常会发现自己编写的任务名称包含下划线::"

#: ../../concepts/namespaces.rst:126
msgid ""
"Similar to how task arguments are processed to turn their underscores "
"into dashes (since that's a common command-line convention) all "
"underscores in task or collection names are interpreted to be dashes "
"instead, by default::"
msgstr ""
"类似于任务参数的处理方式，将它们的下划线转换为破折号（因为这是一个常见的命令行约定），"
"所有任务或集合名称中的下划线都将被解释为破折号，默认情况下::"

#: ../../concepts/namespaces.rst:138
msgid ""
"If you'd prefer the underscores to remain instead, you can update your "
"configuration to set ``tasks.auto_dash_names`` to ``False`` in one of the"
" non-runtime :ref:`config files <config-files>` (system, user, or "
"project.) For example, in ``~/.invoke.yml``::"
msgstr ""
"如果你希望保留下划线，你可以更新你的配置来设置 "
" ``tasks.auto_dash_names`` 到 ``False`` 在一个非运行时 :ref:`config files <config-files>` "
"（系统，用户，或项目）。例如，在 ``~/.invoke.yml``::"

#: ../../concepts/namespaces.rst:147
msgid ""
"In the interests of avoiding confusion, this setting is \"exclusive\" in "
"nature - underscored version of task names *are not valid* on the CLI "
"unless ``auto_dash_names`` is disabled. (However, at the pure function "
"level within Python, they must continue to be referenced with "
"underscores, as dashed names are not valid Python syntax!)"
msgstr ""
"为了避免混淆，这个设置在本质上是 \"exclusive\" -任务名称的下划线版本在 CLI 中无效 "除非 ``auto_dash_names`` 被禁用。"
"（然而，在 Python 的纯函数级别上，它们必须继续用下划线引用，因为虚线名称不是有效的 Python 语法！）"

#: ../../concepts/namespaces.rst:155
msgid "Nesting collections"
msgstr "嵌套集合"

#: ../../concepts/namespaces.rst:157
msgid ""
"The point of namespacing is to have sub-namespaces; to do this in Invoke,"
" create additional `.Collection` instances and add them to their parent "
"collection via `.Collection.add_collection`. For example, let's say we "
"have a couple of documentation tasks::"
msgstr ""
"命名空间的意义是要有子命名空间；要在Invoke中执行此操作，需要创建额外的 `.Collection` 实例，"
"并通过 `.Collection.add_collection` 将它们添加到它们的父集合中。例如，假设我们有几个文档任务 ::"

#: ../../concepts/namespaces.rst:170
msgid "We can bundle them up into a new, named collection like so::"
msgstr "我们可以像这样将它们捆绑到一个新的命名的集合中 ::"

#: ../../concepts/namespaces.rst:176
msgid ""
"And then add this new collection under the root namespace with "
"``add_collection``::"
msgstr ""
"然后用 ``add_collection`` 将这个新集合添加到根命名空间下 ::"

#: ../../concepts/namespaces.rst:181
msgid ""
"The result (assuming for now that ``ns`` currently just contains the "
"original ``release`` task)::"
msgstr ""
"结果（假设 ``ns`` 目前只包含原始的 ``release`` 任务）::"

#: ../../concepts/namespaces.rst:191
msgid ""
"As with tasks, collections may be explicitly bound to their parents with "
"a different name than they were originally given (if any) via a ``name`` "
"kwarg (also, as with ``add_task``, the 2nd regular arg)::"
msgstr ""
"与任务一样，集合可以显式地用不同的名字绑定到它们的父节点上，"
"而不是通过 ``name`` kwarg（也可以像第二个常规参数 ``add_task`` 一样）::"

#: ../../concepts/namespaces.rst:197 ../../concepts/namespaces.rst:365
#: ../../concepts/namespaces.rst:404
msgid "Result::"
msgstr "结果 ::"

#: ../../concepts/namespaces.rst:208
msgid "Importing modules as collections"
msgstr "将模块作为集合导入"

#: ../../concepts/namespaces.rst:210
msgid ""
"A simple tactic which Invoke itself uses in the trivial, single-module "
"case is to use `.Collection.from_module` -- a classmethod serving as an "
"alternate ``Collection`` constructor which takes a Python module object "
"as its first argument."
msgstr ""
"在简单的单模块情况下，Invoke 本身使用的简单策略是使用类方法 `.Collection.from_module`，"
"作为另一个 ``Collection`` 构造函数，它接受 Python 模块对象作为第一个参数。"

#: ../../concepts/namespaces.rst:215
msgid ""
"Modules given to this method are scanned for ``Task`` instances, which "
"are added to a new ``Collection``. By default, this collection's name is "
"taken from the module name (the ``__name__`` attribute), though it can "
"also be supplied explicitly."
msgstr ""
"给定方法的模块被扫描为 ``Task`` 实例，这些实例被添加到新的 ``Collection``。"
"默认情况下，该集合的名称取自模块名称（``__name__`` 属性），但它也可以显式提供。"

#: ../../concepts/namespaces.rst:221
msgid ""
"As with the default task module, you can override this default loading "
"behavior by declaring a ``ns`` or ``namespace`` `.Collection` object at "
"top level in the loaded module."
msgstr ""
"和默认的任务模块一样，你可以通过声明 ``ns`` 或 ``namespace`` `.Collection`  来覆盖这个默认的加载行为。"
"在被加载模块的顶层。"

#: ../../concepts/namespaces.rst:225
msgid ""
"For example, let's reorganize our earlier single-file example into a "
"Python package with several submodules. First, ``tasks/release.py``::"
msgstr ""
"例如，让我们将之前的单文件示例重组为一个带有几个子模块的 Python 包。首先，``tasks/release.py``::"

#: ../../concepts/namespaces.rst:234
msgid "And ``tasks/docs.py``::"
msgstr "添加 ``tasks/docs.py``::"

#: ../../concepts/namespaces.rst:246
msgid "Tying them together is ``tasks/__init__.py``::"
msgstr "把它们联系在一起 ``tasks/__init__.py``::"

#: ../../concepts/namespaces.rst:256
msgid ""
"This form of the API is a little unwieldy in practice. Thankfully there's"
" a shortcut: ``add_collection`` will notice when handed a module object "
"as its first argument and call ``Collection.from_module`` for you "
"internally::"
msgstr ""
"这种形式的 API 在实践中有点笨拙。"
"幸运的是，有快捷方式 ``add_collection`` 会注意到当传入模块对象作为它的第一个参数时，并在内部为你调用 ``Collection.from_module``"

#: ../../concepts/namespaces.rst:264
msgid "Either way, the result::"
msgstr "无论哪种方式，结果都是 ::"

#: ../../concepts/namespaces.rst:275
msgid "Default tasks"
msgstr "默认任务"

#: ../../concepts/namespaces.rst:277
msgid ""
"Tasks may be declared as the default task to invoke for the collection "
"they belong to, e.g. by giving ``default=True`` to `@task <.task>` (or to"
" `.Collection.add_task`.) This is useful when you have a bunch of related"
" tasks in a namespace but one of them is the most commonly used, and maps"
" well to the namespace as a whole."
msgstr ""

#: ../../concepts/namespaces.rst:283
msgid ""
"For example, in the documentation submodule we've been experimenting with"
" so far, the ``build`` task makes sense as a default, so we can say "
"things like ``invoke docs`` as a shortcut to ``invoke docs.build``. This "
"is easy to do::"
msgstr ""

#: ../../concepts/namespaces.rst:291
msgid ""
"When imported into the root namespace (as shown above) this alters the "
"output of ``--list``, highlighting the fact that ``docs.build`` can be "
"invoked as ``docs`` if desired::"
msgstr ""

#: ../../concepts/namespaces.rst:303
msgid "Default subcollections"
msgstr ""

#: ../../concepts/namespaces.rst:305
msgid ""
"As of version 1.5, this functionality is also extended to subcollections:"
" a subcollection can be specified as the default when being added to its "
"parent collection, and that subcollection's own default task (or sub-"
"subcollection!) will be invoked as the default for the parent."
msgstr ""

#: ../../concepts/namespaces.rst:310
msgid ""
"An example probably makes that clearer. Here's a tiny inline task tree "
"with two subcollections, each with their own default task::"
msgstr ""

#: ../../concepts/namespaces.rst:331
msgid ""
"Then we tie those into one top level collection, setting the ``build`` "
"subcollection as the overall default::"
msgstr ""

#: ../../concepts/namespaces.rst:338
msgid "The result is that ``build.all`` becomes the absolute default task::"
msgstr ""

#: ../../concepts/namespaces.rst:344
msgid "Mix and match"
msgstr ""

#: ../../concepts/namespaces.rst:346
msgid ""
"You're not limited to the specific tactics shown above -- now that you "
"know the basic tools of ``add_task`` and ``add_collection``, use whatever"
" approach best fits your needs."
msgstr ""

#: ../../concepts/namespaces.rst:350
msgid ""
"For example, let's say you wanted to keep things organized into "
"submodules, but wanted to \"promote\" ``release.release`` back to the top"
" level for convenience's sake. Just because it's stored in a module "
"doesn't mean we must use ``add_collection`` -- we could instead import "
"the task itself and use ``add_task`` directly::"
msgstr ""

#: ../../concepts/namespaces.rst:376
msgid "More shortcuts"
msgstr ""

#: ../../concepts/namespaces.rst:378
msgid ""
"Finally, you can even skip ``add_collection`` and ``add_task`` if your "
"needs are simple enough -- `.Collection`'s constructor will take unknown "
"arguments and build the namespace from their values as appropriate::"
msgstr ""

#: ../../concepts/namespaces.rst:389
msgid ""
"Notice how we gave both a task object (``release.release``) and a module "
"containing tasks (``docs``). The result is identical to the above::"
msgstr ""

#: ../../concepts/namespaces.rst:399
msgid ""
"If given as keyword arguments, the keywords act like the ``name`` "
"arguments do in the ``add_*`` methods. Naturally, both can be mixed "
"together as well::"
msgstr ""

#: ../../concepts/namespaces.rst:414
msgid ""
"You can still name these ``Collection`` objects with a leading string "
"argument if desired, which can be handy when building sub-collections."
msgstr ""

