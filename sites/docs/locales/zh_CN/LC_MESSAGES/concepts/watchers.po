# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022 Jeff Forcier
# This file is distributed under the same license as the Invoke package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Invoke \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-27 16:23+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.0\n"

#: ../../concepts/watchers.rst:5
msgid "Automatically responding to program output"
msgstr "自动响应程序输出"

#: ../../concepts/watchers.rst:8
msgid "Background"
msgstr "背景"

#: ../../concepts/watchers.rst:10
msgid ""
"Command-line programs tend to be designed for interactive shells, which "
"frequently manifests as waiting around for user input, or \"prompts\". "
"Well-designed programs offer options for pre-empting such prompts, "
"resulting in an easily automated workflow -- but with the rest, "
"interactivity is unavoidable."
msgstr ""
"命令行程序往往是为交互式 shell 设计的，这通常表现为等待用户输入或‘提示’。"
"设计良好的程序提供了预先应对此类提示的选项，从而实现易于自动化的工作流程——但对于其他程序，交互性是不可避免的。"

#: ../../concepts/watchers.rst:16
msgid ""
"Thankfully, Invoke's `.Runner` class not only forwards your standard "
"input to the running program (allowing you to manually respond to "
"prompts) but it can also be configured to respond automatically on your "
"behalf."
msgstr ""
"幸运的是，Invoke 的 `.Runner` 类不仅将你的标准输入转发给正在运行的程序（允许你手动响应提示），还可以配置为自动代表你进行响应。"

#: ../../concepts/watchers.rst:21
msgid "Basic use"
msgstr "基本用法"

#: ../../concepts/watchers.rst:23
msgid ""
"The mechanism for this automation is the ``watchers`` kwarg to the "
"`.Runner.run` method (and its wrappers elsewhere, such as `.Context.run` "
"and `invoke.run`), which is a list of `.StreamWatcher`-subclass instances"
" configured to watch for patterns & respond accordingly. The simplest of "
"these is `.Responder`, which just replies with its configured response "
"every time its pattern is seen; others can be found in the :doc:`watchers"
" module </api/watchers>`."
msgstr ""
"这种自动化的机制是 `.Runner.run` 方法（及其在其他地方的包装器，如 `.Context.run` 和 `invoke.run`）的 ``watchers`` 关键字参数，"
"它是 `.StreamWatcher` 子类实例的列表，配置为监视模式并相应地响应。其中最简单的是 `.Responder`，"
"它每次看到其配置的模式时都会回复其配置的响应；其他的可以在 :doc:`watchers 模块 </api/watchers>` 中找到。"

#: ../../concepts/watchers.rst:32
msgid ""
"As with all other arguments to ``run``, you can also set the default set "
"of watchers globally via :doc:`configuration files <configuration>`."
msgstr ""
"与 ``run`` 的所有其他参数一样，你也可以通过 :doc:`配置文件 <configuration>` 全局设置默认的 watchers 集合。"

#: ../../concepts/watchers.rst:35
msgid ""
"Take for example this program which expects a manual response to a yes/no"
" prompt::"
msgstr ""
"以这个需要手动响应是/否提示的程序为例::"

#: ../../concepts/watchers.rst:43
msgid ""
"You *could* call ``run(\"excitable-program\")``, manually watch for the "
"prompt, and mash Y by hand. But if you instead supply a `.Responder` like"
" so::"
msgstr ""
"你*可以*调用 ``run(\"excitable-program\")``，手动监视提示并手动按下 Y。但如果你像这样提供一个 `.Responder`::"

#: ../../concepts/watchers.rst:54
msgid ""
"Then `.Runner` passes the program's ``stdout`` and ``stderr`` through "
"``responder``, which watches for ``\"Are you ready? [Y/n] \"`` and "
"automatically writes ``y`` (plus ``\\n`` to simulate hitting "
"Enter/Return) to the program's ``stdin``."
msgstr ""
"然后 `.Runner` 将程序的 ``stdout`` 和 ``stderr`` 传递给 ``responder``，"
"它会监视 ``\"Are you ready? [Y/n] \"`` 并自动写入 ``y`` （加上 ``\\n`` 以模拟按下 Enter/Return）到程序的 ``stdin``。"

#: ../../concepts/watchers.rst:60
msgid ""
"The pattern argument to `.Responder` is treated as a `regular expression "
"<re>`, requiring more care (note how we had to escape our square-brackets"
" in the above example) but providing more power as well."
msgstr ""
"`.Responder` 的 pattern 参数被视为 `正则表达式 <re>`，"
"需要更加小心（注意在上面的示例中我们如何转义方括号），但也提供了更强大的功能。"
