# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022 Jeff Forcier
# This file is distributed under the same license as the Invoke package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Invoke \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-01-27 16:23+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.0\n"

#: ../../concepts/configuration.rst:5
msgid "Configuration"
msgstr "配置"

#: ../../concepts/configuration.rst:8
msgid "Introduction"
msgstr "简介"

#: ../../concepts/configuration.rst:10
msgid ""
"Invoke offers a multifaceted configuration mechanism allowing you to "
"configure both core behavior and that of your tasks, via a hierarchy of "
"configuration files, environment variables, :doc:`task namespaces "
"</concepts/namespaces>` and CLI flags."
msgstr ""
"invoke 提供了多方面的配置机制，通过配置文件、环境变量、"
":doc:`任务名称空间 </concepts/namespaces>` 和 CLI 标志的层次结构，"
"允许配置核心行为和任务的行为。"

#: ../../concepts/configuration.rst:15
msgid ""
"The end result of configuration seeking, loading, parsing & merging is a "
"`.Config` object, which behaves like a (nested) Python dictionary. Invoke"
" references this object when it runs (determining the default behavior of"
" methods like `.Context.run`) and exposes it to users' tasks as "
"`.Context.config` or as shorthand attribute access on the `.Context` "
"itself."
msgstr ""
"配置查找、加载、解析和合并的最终结果是 `.Config` 对象，"
"它的行为类似于（嵌套的）Python 字典。"
"当它运行时调用引用此对象（确定方法的默认行为，如 `.Context.run`），"
"并将它作为 `.Context.config` 暴露给用户的任务或作为 `.Context` 上的快捷属性访问。"

#: ../../concepts/configuration.rst:25
msgid "The configuration hierarchy"
msgstr "配置的层次结构"

#: ../../concepts/configuration.rst:27
msgid ""
"In brief, the order in which configuration values override one another is"
" as follows:"
msgstr ""
"简而言之，配置值相互覆盖的顺序如下："

#: ../../concepts/configuration.rst:30
msgid ""
"**Internal default values** for behaviors which are controllable via "
"configuration. See :ref:`default-values` for details."
msgstr ""
"通过配置可以控制 **内部默认行为值**。详细信息请参见 :ref:`default-values`。"

#: ../../concepts/configuration.rst:32
msgid ""
"**Collection-driven configurations** defined in tasks modules via "
"`.Collection.configure`. (See :ref:`collection-configuration` below for "
"details.)"
msgstr ""

#: ../../concepts/configuration.rst:36
msgid ""
"Sub-collections' configurations get merged into the top level collection "
"and the final result forms the basis of the overall configuration setup."
msgstr ""

#: ../../concepts/configuration.rst:39
msgid ""
"**System-level configuration file** stored in ``/etc/``, such as "
"``/etc/invoke.yaml``. (See :ref:`config-files` for details on this and "
"the other config-file entries.)"
msgstr ""

#: ../../concepts/configuration.rst:42
msgid ""
"**User-level configuration file** found in the running user's home "
"directory, e.g. ``~/.invoke.yaml``."
msgstr ""

#: ../../concepts/configuration.rst:44
msgid ""
"**Project-level configuration file** living next to your top level "
"``tasks.py``. For example, if your run of Invoke loads "
"``/home/user/myproject/tasks.py`` (see our docs on :doc:`the load process"
" </concepts/loading>`), this might be "
"``/home/user/myproject/invoke.yaml``."
msgstr ""

#: ../../concepts/configuration.rst:48
msgid "**Environment variables** found in the invoking shell environment."
msgstr ""

#: ../../concepts/configuration.rst:50
msgid ""
"These aren't as strongly hierarchical as the rest, nor is the shell "
"environment namespace owned wholly by Invoke, so we must rely on slightly"
" verbose prefixing instead - see :ref:`env-vars` for details."
msgstr ""

#: ../../concepts/configuration.rst:54
msgid ""
"**Runtime configuration file** whose path is given to :option:`-f`, e.g. "
"``inv -f /random/path/to/config_file.yaml``. This path may also be set "
"via the ``INVOKE_RUNTIME_CONFIG`` env var."
msgstr ""

#: ../../concepts/configuration.rst:57
msgid "**Command-line flags** for certain core settings, such as :option:`-e`."
msgstr ""

#: ../../concepts/configuration.rst:58
msgid "**Modifications made by user code** at runtime."
msgstr ""

#: ../../concepts/configuration.rst:64
msgid "Default configuration values"
msgstr ""

#: ../../concepts/configuration.rst:66
msgid ""
"Below is a list of all the configuration values and/or section Invoke "
"itself uses to control behaviors such as `.Context.run`'s ``echo`` and "
"``pty`` flags, task deduplication, and so forth."
msgstr ""

#: ../../concepts/configuration.rst:71
msgid ""
"The storage location for these values is inside the `.Config` class, "
"specifically as the return value of `.Config.global_defaults`; see its "
"API docs for more details."
msgstr ""

#: ../../concepts/configuration.rst:75
msgid ""
"For convenience, we refer to nested setting names with a dotted syntax, "
"so e.g. ``foo.bar`` refers to what would be (in a Python config context) "
"``{'foo': {'bar': <value here>}}``. Typically, these can be read or set "
"on `.Config` and `.Context` objects using attribute syntax, which looks "
"nearly identical: ``c.foo.bar``."
msgstr ""

#: ../../concepts/configuration.rst:81
msgid "The ``tasks`` config tree holds settings relating to task execution."
msgstr ""

#: ../../concepts/configuration.rst:83
msgid ""
"``tasks.dedupe`` controls :ref:`deduping` and defaults to ``True``. It "
"can also be overridden at runtime via :option:`--no-dedupe`."
msgstr ""

#: ../../concepts/configuration.rst:85
msgid ""
"``tasks.auto_dash_names`` controls whether task and collection names have"
" underscores turned to dashes on the CLI. Default: ``True``. See also "
":ref:`dashes-vs-underscores`."
msgstr ""

#: ../../concepts/configuration.rst:88
msgid ""
"``tasks.collection_name`` controls the Python import name sought out by "
":ref:`collection discovery <collection-discovery>`, and defaults to "
"``\"tasks\"``."
msgstr ""

#: ../../concepts/configuration.rst:91
msgid ""
"``tasks.executor_class`` allows users to override the class instantiated "
"and used for task execution."
msgstr ""

#: ../../concepts/configuration.rst:94
msgid ""
"Must be a fully-qualified dotted path of the form "
"``module(.submodule...).class``, where all but ``.class`` will be handed "
"to `importlib.import_module`, and ``class`` is expected to be an "
"attribute on that resulting module object."
msgstr ""

#: ../../concepts/configuration.rst:99
msgid ""
"Defaults to ``None``, meaning to use the running `.Program` object's "
"``executor_class`` attribute."
msgstr ""

#: ../../concepts/configuration.rst:103
msgid ""
"Take care if using this setting in tandem with :ref:`custom program "
"binaries <reusing-as-a-binary>`, since custom programs may specify their "
"own default executor class (which your use of this setting will "
"override!) and assume certain behaviors stemming from that."
msgstr ""

#: ../../concepts/configuration.rst:108
msgid ""
"``tasks.search_root`` allows overriding the default :ref:`collection "
"discovery <collection-discovery>` root search location. It defaults to "
"``None``, which indicates to use the executing process' current working "
"directory."
msgstr ""

#: ../../concepts/configuration.rst:113
msgid ""
"The ``run`` tree controls the behavior of `.Runner.run`. Each member of "
"this tree (such as ``run.echo`` or ``run.pty``) maps directly to a "
"`.Runner.run` keyword argument of the same name; see that method's "
"docstring for details on what these settings do & what their default "
"values are."
msgstr ""

#: ../../concepts/configuration.rst:117
msgid ""
"The ``runners`` tree controls _which_ runner classes map to which "
"execution contexts; if you're using Invoke by itself, this will only tend"
" to have a single member, ``runners.local``. Client libraries may extend "
"it with additional key/value pairs, such as ``runners.remote``."
msgstr ""

#: ../../concepts/configuration.rst:121
msgid "The ``sudo`` tree controls the behavior of `.Context.sudo`:"
msgstr ""

#: ../../concepts/configuration.rst:123
msgid ""
"``sudo.password`` controls the autoresponse password submitted to sudo's "
"password prompt. Default: ``None``."
msgstr ""

#: ../../concepts/configuration.rst:127
msgid ""
"While it's possible to store this setting, like any other, in "
":doc:`configuration files </concepts/configuration>` -- doing so is "
"inherently insecure. We highly recommend filling this config value in at "
"runtime from a secrets management system of some kind."
msgstr ""

#: ../../concepts/configuration.rst:132
msgid ""
"``sudo.prompt`` holds the sudo password prompt text, which is both "
"supplied to ``sudo -p``, and searched for when performing :doc:`auto-"
"response </concepts/watchers>`. Default: ``[sudo] password:``."
msgstr ""

#: ../../concepts/configuration.rst:136
msgid ""
"A top level config setting, ``debug``, controls whether debug-level "
"output is logged; it defaults to ``False``."
msgstr ""

#: ../../concepts/configuration.rst:139
msgid ""
"``debug`` can be toggled via the :option:`-d` CLI flag, which enables "
"debugging after CLI parsing runs. It can also be toggled via the "
"``INVOKE_DEBUG`` environment variable which - unlike regular env vars - "
"is honored from the start of execution and is thus useful for "
"troubleshooting parsing and/or config loading."
msgstr ""

#: ../../concepts/configuration.rst:145
msgid ""
"A small config tree, ``timeouts``, holds various kinds of timeout "
"controls. At present, for Invoke, this only holds a ``command`` subkey, "
"which controls subprocess execution timeouts."
msgstr ""

#: ../../concepts/configuration.rst:149
msgid ""
"Client code often adds more to this tree, and Invoke itself may add more "
"in the future as well."
msgstr ""

#: ../../concepts/configuration.rst:156
msgid "Configuration files"
msgstr ""

#: ../../concepts/configuration.rst:159
msgid "Loading"
msgstr ""

#: ../../concepts/configuration.rst:161
msgid ""
"For each configuration file location mentioned in the previous section, "
"we search for files ending in ``.yaml``, ``.yml``, ``.json`` or ``.py`` "
"(**in that order!**), load the first one we find, and ignore any others "
"that might exist."
msgstr ""

#: ../../concepts/configuration.rst:165
msgid ""
"For example, if Invoke is run on a system containing both "
"``/etc/invoke.yml`` *and* ``/etc/invoke.json``, **only the YAML file will"
" be loaded**. This helps keep things simple, both conceptually and in the"
" implementation."
msgstr ""

#: ../../concepts/configuration.rst:170
msgid "Format"
msgstr ""

#: ../../concepts/configuration.rst:172
msgid ""
"Invoke's configuration allows arbitrary nesting, and thus so do our "
"config file formats. All three of the below examples result in a "
"configuration equivalent to ``{'debug': True, 'run': {'echo': True}}``:"
msgstr ""

#: ../../concepts/configuration.rst:176
msgid "**YAML**"
msgstr ""

#: ../../concepts/configuration.rst:184
msgid "**JSON**"
msgstr ""

#: ../../concepts/configuration.rst:195
msgid "**Python**::"
msgstr ""

#: ../../concepts/configuration.rst:202
msgid "For further details, see these languages' own documentation."
msgstr ""

#: ../../concepts/configuration.rst:208
msgid "Environment variables"
msgstr ""

#: ../../concepts/configuration.rst:210
msgid ""
"Environment variables are a bit different from other configuration-"
"setting methods, since they don't provide a clean way to nest "
"configuration keys, and are also implicitly shared amongst the entire "
"system's installed application base."
msgstr ""

#: ../../concepts/configuration.rst:215
msgid ""
"In addition, due to implementation concerns, env vars must be pre-"
"determined by the levels below them in the config hierarchy (in other "
"words - env vars may only be used to override existing config values). If"
" you need Invoke to understand a ``FOOBAR`` environment variable, you "
"must first declare a ``foobar`` setting in a configuration file or in "
"your task collections."
msgstr ""

#: ../../concepts/configuration.rst:222
msgid "Basic rules"
msgstr ""

#: ../../concepts/configuration.rst:224
msgid ""
"To mitigate the shell namespace problem, we simply prefix all our env "
"vars with ``INVOKE_``."
msgstr ""

#: ../../concepts/configuration.rst:227
msgid ""
"Nesting is performed via underscore separation, so a setting that looks "
"like e.g. ``{'run': {'echo': True}}`` at the Python level becomes "
"``INVOKE_RUN_ECHO=1`` in a typical shell. See :ref:`env-var-nesting` "
"below for more on this."
msgstr ""

#: ../../concepts/configuration.rst:233
msgid "Type casting"
msgstr ""

#: ../../concepts/configuration.rst:235
msgid ""
"Since env vars can only be used to override existing settings, the "
"previous value of a given setting is used as a guide in casting the "
"strings we get back from the shell:"
msgstr ""

#: ../../concepts/configuration.rst:239
msgid ""
"If the current value is a string or Unicode object, it is replaced with "
"the value from the environment, with no casting whatsoever;"
msgstr ""

#: ../../concepts/configuration.rst:242
msgid ""
"Depending on interpreter and environment, this means that a setting "
"defaulting to a non-Unicode string type (eg a ``str`` on Python 2) may "
"end up replaced with a Unicode string, or vice versa. This is intentional"
" as it prevents users from accidentally limiting themselves to non-"
"Unicode strings."
msgstr ""

#: ../../concepts/configuration.rst:248
msgid ""
"If the current value is ``None``, it too is replaced with the string from"
" the environment;"
msgstr ""

#: ../../concepts/configuration.rst:250
msgid ""
"Booleans are set as follows: ``0`` and the empty value/string (e.g. "
"``SETTING=``, or ``unset SETTING``, or etc) evaluate to ``False``, and "
"any other value evaluates to ``True``."
msgstr ""

#: ../../concepts/configuration.rst:253
msgid "Lists and tuples are currently unsupported and will raise an exception;"
msgstr ""

#: ../../concepts/configuration.rst:255
msgid ""
"In the future we may implement convenience transformations, such as "
"splitting on commas to form a list; however since users can always "
"perform such operations themselves, it may not be a high priority."
msgstr ""

#: ../../concepts/configuration.rst:259
msgid ""
"All other types - integers, longs, floats, etc - are simply used as "
"constructors for the incoming value."
msgstr ""

#: ../../concepts/configuration.rst:262
msgid ""
"For example, a ``foobar`` setting whose default value is the integer "
"``1`` will run all env var inputs through `int`, and thus ``FOOBAR=5`` "
"will result in the Python value ``5``, not ``\"5\"``."
msgstr ""

#: ../../concepts/configuration.rst:269
msgid "Nesting vs underscored names"
msgstr ""

#: ../../concepts/configuration.rst:271
msgid ""
"Since environment variable keys are single strings, we must use some form"
" of string parsing to allow access to nested configuration settings. As "
"mentioned above, in basic use cases this just means using an underscore "
"character: ``{'run': {'echo': True}}`` becomes ``INVOKE_RUN_ECHO=1``."
msgstr ""

#: ../../concepts/configuration.rst:276
msgid ""
"However, ambiguity is introduced when the settings names themselves "
"contain underscores: is ``INVOKE_FOO_BAR=baz`` equivalent to ``{'foo': "
"{'bar': 'baz'}}``, or to ``{'foo_bar': 'baz'}``? Thankfully, because env "
"vars can only be used to modify settings declared at the Python level or "
"in config files, we look at the current state of the config to determine "
"the answer."
msgstr ""

#: ../../concepts/configuration.rst:282
msgid ""
"There is still a corner case where *both* possible interpretations exist "
"as valid config paths (e.g. ``{'foo': {'bar': 'default'}, 'foo_bar': "
"'otherdefault'}``). In this situation, we honor the `Zen of Python <http"
"://zen-of-python.info/in-the-face-of-ambiguity-refuse-the-temptation-to-"
"guess.html#12>`_ and refuse to guess; an error is raised instead, "
"counseling users to modify their configuration layout or avoid using env "
"vars for the setting in question."
msgstr ""

#: ../../concepts/configuration.rst:293
msgid "`.Collection`-based configuration"
msgstr "基于 `.Collection` 的配置"

#: ../../concepts/configuration.rst:295
msgid ""
"`.Collection` objects may contain a config mapping, set via "
"`.Collection.configure`, and (as per :ref:`the hierarchy <config-"
"hierarchy>`) this typically forms the lowest level of configuration in "
"the system."
msgstr ""
"`.Collection` 对象可以包含配置映射，通过 `.Collection.configure` 来设置，"
"并且（按照 :ref:`层次结构 <config-hierarchy>`）这通常形成了系统中最低级别的配置。"

#: ../../concepts/configuration.rst:299
msgid ""
"When collections are :doc:`nested </concepts/namespaces>`, configuration "
"is merged 'downwards' by default: when conflicts arise, outer namespaces "
"closer to the root will win, versus inner ones closer to the task being "
"invoked."
msgstr ""
"当集合是 :doc:`嵌套 </concepts/namespaces>` 时，"
"配置默认是 '向下' 合并：当冲突出现时，相对于靠近被调用任务的内部命名空间，"
"靠近根的外部命名空间将获胜。"

#: ../../concepts/configuration.rst:304
msgid ""
"'Inner' tasks here are specifically those on the path from the root to "
"the one housing the invoked task. 'Sibling' subcollections are ignored."
msgstr ""
"这里的“内部”任务是指从根目录到被调用任务所在目录的路径上的任务。'Sibling' 子集合将被忽略。"

#: ../../concepts/configuration.rst:307
msgid "A quick example of what this means::"
msgstr "举个简单的例子 ::"

#: ../../concepts/configuration.rst:323
msgid "The result of calling ``inner.mytask``::"
msgstr "调用 ``inner.mytask`` 的结果 ::"

#: ../../concepts/configuration.rst:330
msgid "Example of real-world config use"
msgstr "真实世界配置使用的例子"

#: ../../concepts/configuration.rst:332
msgid ""
"The previous sections had small examples within them; this section "
"provides a more realistic-looking set of examples showing how the config "
"system works."
msgstr ""
"前面的章节中有一些小例子；本节提供了一组看起来更真实的例子，展示了配置系统是如何工作的。"

#: ../../concepts/configuration.rst:336
msgid "Setup"
msgstr "设置"

#: ../../concepts/configuration.rst:338
msgid ""
"We'll start out with semi-realistic tasks that hardcode their values, and"
" build up to using the various configuration mechanisms. A small module "
"for building `Sphinx <http://sphinx-doc.org>`_ docs might begin like "
"this::"
msgstr ""
"从硬编码其值的半现实的任务开始，然后使用各种配置机制进行构建。"
"用于构建 `Sphinx <http://sphinx-doc.org>`_  docs 的小模块可以这样开始 ::"

#: ../../concepts/configuration.rst:352
msgid "Then maybe you refactor the build target::"
msgstr "然后重构构建目标 ::"

#: ../../concepts/configuration.rst:364
msgid "We can also allow runtime parameterization::"
msgstr "还可以允许运行时参数化 ::"

#: ../../concepts/configuration.rst:376
msgid ""
"This task module works for a single set of users, but what if we want to "
"allow reuse? Somebody may want to use this module with a different "
"default target. Using the configuration data (made available via the "
"context arg) to configure these settings is usually the better solution "
"[1]_."
msgstr ""
"这个任务模块只适用于一组用户，但如果我们希望允许重用呢？"
"有些人可能希望将此模块与另一个默认目标一起使用。"
"使用配置数据（通过上下文参数提供）来配置这些设置通常是更好的解决方案。[1]_"

#: ../../concepts/configuration.rst:382
msgid "Configuring via task collection"
msgstr "任务 collection 配置"

#: ../../concepts/configuration.rst:384
msgid ""
"The configuration `setting <.Collection.configure>` and `getting "
"<.Context.config>` APIs enable moving otherwise 'hardcoded' default "
"values into a config structure which downstream users are free to "
"redefine. Let's apply this to our example. First we add an explicit "
"namespace object::"
msgstr ""
"配置 `setting <.Collection.configure>` 和 `getting <.Context.config>` "
"允许将其他的‘硬编码’默认值移动到配置结构中，下游用户可以自由地重新定义。"
"让我们把这个应用到我们的例子中。首先，我们添加一个显式的命名空间对象 ::"

#: ../../concepts/configuration.rst:403
msgid ""
"Then we can move the default build target value into the collection's "
"default configuration, and refer to it via the context. At this point we "
"also change our kwarg default value to be ``None`` so we can determine "
"whether or not a runtime value was given.  The result::"
msgstr ""
"然后，可以将默认构建目标值移到集合的默认配置中，并通过上下文引用它。"
"在这一点上，也将 kwarg 的默认值改为 ``None``，"
"这样就可以确定是否给出了一个运行时值。结果 ::"

#: ../../concepts/configuration.rst:423
msgid ""
"The result isn't significantly more complex than what we began with, and "
"as we'll see next, it's now trivial for users to override your defaults "
"in various ways."
msgstr ""
"结果并不比我们开始时更复杂，正如我们接下来将看到的，现在用户以各种方式重写默认值是微不足道的。"

#: ../../concepts/configuration.rst:428
msgid "Configuration overriding"
msgstr "配置覆盖"

#: ../../concepts/configuration.rst:430
msgid ""
"The lowest-level override is, of course, just modifying the local "
"`.Collection` tree into which a distributed module has been imported. "
"E.g. if the above module is distributed as ``myproject.docs``, someone "
"can define a ``tasks.py`` that does this::"
msgstr ""
"当然，最低级别的覆盖只是修改本地 `.Collection` 树，其中导入了分布式模块。"
"例如，如果上面的模块是作为 ``myproject.docs`` 分发的，可以定义 ``tasks.py`` 来做这个 ::"

#: ../../concepts/configuration.rst:446
msgid "And then they can add this to the bottom::"
msgstr "然后把这个加到下面 ::"

#: ../../concepts/configuration.rst:451
msgid ""
"Now we have a ``docs`` sub-namespace whose build target defaults to "
"``built_docs`` instead of ``docs/_build``. Runtime users can still "
"override this via flags (e.g. ``inv docs.build "
"--target='some/other/dir'``) just as before."
msgstr ""
"现在有了 ``docs`` 子命名空间，它的构建目标默认为 ``built_docs``，而不是 ``docs/_build``。"
"运行时用户仍然可以通过旗标（例如 ``inv docs.build --target='some/other/dir'``）像以前一样构建。"

#: ../../concepts/configuration.rst:456
msgid ""
"If you prefer configuration files over in-Python tweaking of your "
"namespace tree, that works just as well; instead of adding the line above"
" to the previous snippet, instead drop this into a file next to "
"``tasks.py`` named ``invoke.yaml``::"
msgstr ""
"如果你更喜欢配置文件而不是在 python 中调整你的命名空间树，这也可以；"
"不要把上面的代码添加到前面的代码片段中，"
"而是把它放到 ``tasks.py`` 旁边的名为 ``invoke.yaml`` 的文件中 ::"

#: ../../concepts/configuration.rst:464
msgid ""
"For this example, that sort of local-to-project conf file makes the most "
"sense, but don't forget that the :ref:`config hierarchy <config-"
"hierarchy>` offers additional configuration methods which may be suitable"
" depending on your needs."
msgstr ""
"在这个例子中，那种 local-to-project 的配置文件是最有意义的，"
"但是不要忘记 :ref:`config hierarchy <config-hierarchy>` 提供了额外的配置方法，"
"根据你的需要可能是合适的。"

#: ../../concepts/configuration.rst:470
msgid "Footnotes"
msgstr "脚注"

#: ../../concepts/configuration.rst:472
msgid ""
"Copying and modifying the file breaks code reuse; overriding the module-"
"level ``default_path`` variable won't play well with concurrency; "
"wrapping the tasks with different default arguments works but is fragile "
"and adds boilerplate."
msgstr ""
"复制和修改文件会破坏代码重用；重写模块级的 ``default_path`` 变量将不能很好地处理并发性；"
"用不同的默认参数包装任务可以工作，但很脆弱，会增加样板文件。"
