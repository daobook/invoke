
<!DOCTYPE html>

<html lang="zh_CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>常见问题 &#8212; Invoke  文档</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/translations.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="搜索" href="search.html" />
    <link rel="next" title="安装" href="installing.html" />
    <link rel="prev" title="Changelog" href="changelog.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="frequently-asked-questions">
<h1>常见问题<a class="headerlink" href="#frequently-asked-questions" title="永久链接至标题">¶</a></h1>
<section id="general-project-questions">
<h2>一般项目问题<a class="headerlink" href="#general-project-questions" title="永久链接至标题">¶</a></h2>
<section id="why-was-invoke-split-off-from-the-fabric-project">
<span id="invoke-split-from-fabric"></span><h3>为什么 Invoke 从 <a class="reference external" href="http://fabfile.org">Fabric</a> 项目中分离出来？<a class="headerlink" href="#why-was-invoke-split-off-from-the-fabric-project" title="永久链接至标题">¶</a></h3>
<p>Fabric（1.x 和更早）是一个混合项目，实现了两个功能集： 任务执行（组织任务功能，通过 CLI 执行它们，以及本地 shell 命令）和高水平的 SSH 行动（组织服务器/主机，远程 shell 命令，以及文件传输）。</p>
<p>对于需要这两套功能的用例，这种安排效果很好。然而，随着时间的推移，人们发现许多用户只需要一个或另一个，只在本地使用的用户对沉重的SSH/密码安装要求感到不满，而专注于远程的用户则对混合代码库造成的API限制感到挣扎。</p>
<p>在规划 Fabric 2.x 时，将 “local” 功能集作为一个独立的库是有意义的，而将 SSH 组件设计成上面的一个独立层似乎是合理的。因此，Invoke 的创建是为了专门关注本地和抽象的问题，让 Fabric 2.x 只关注服务器和网络命令</p>
<p>Fabric 2 利用了 Invoke 的 API 的许多部分，并允许（但不要求！）使用 Invoke 的 CLI 功能，允许多种用例（构建工具、高级 SSH 库、混合构建/编排工具）共存，而不会对彼此产生负面影响。</p>
</section>
</section>
<section id="defining-executing-tasks">
<h2>定义/执行任务<a class="headerlink" href="#defining-executing-tasks" title="永久链接至标题">¶</a></h2>
<section id="my-task-s-first-argument-isn-t-showing-up-in-help">
<span id="bad-first-arg"></span><h3>我的任务的第一个参数没有显示在 <code class="docutils literal notranslate"><span class="pre">--help</span></code> 中！<a class="headerlink" href="#my-task-s-first-argument-isn-t-showing-up-in-help" title="永久链接至标题">¶</a></h3>
<p>如果你忘记为你的任务定义一个初始上下文参数，这个问题就会冒出来。</p>
<p>例如，你能发现这个任务文件样本中的问题吗？</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">invoke</span> <span class="kn">import</span> <span class="n">task</span>

<span class="nd">@task</span>
<span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">where</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="nd">@task</span>
<span class="k">def</span> <span class="nf">clean</span><span class="p">(</span><span class="n">what</span><span class="p">):</span>
    <span class="k">pass</span>
</pre></div>
</div>
<p>当用 <code class="docutils literal notranslate"><span class="pre">inv</span> <span class="pre">--list</span></code> 或 <code class="docutils literal notranslate"><span class="pre">inv</span> <span class="pre">--help</span></code> 检查这个任务文件时，并没有引起明显的错误。然而，<code class="docutils literal notranslate"><span class="pre">clean</span></code> 忘记了为上下文预留第一个参数 – 所以 Invoke 把 <code class="docutils literal notranslate"><span class="pre">what</span></code> 当作上下文参数！这意味着它没有显示在帮助中。这意味着它不会出现在帮助输出或其他命令行解析阶段”</p>
</section>
<section id="the-command-line-says-my-task-s-first-argument-is-invalid">
<h3>命令行说我的任务的第一个参数是无效的！<a class="headerlink" href="#the-command-line-says-my-task-s-first-argument-is-invalid" title="永久链接至标题">¶</a></h3>
<p>参见 <a class="reference internal" href="#bad-first-arg"><span class="std std-ref">我的任务的第一个参数没有显示在 --help 中！</span></a> - 这可能是同一个问题。</p>
</section>
</section>
<section id="running-local-shell-commands-run">
<h2>运行本地shell命令（<code class="docutils literal notranslate"><span class="pre">run</span></code>）<a class="headerlink" href="#running-local-shell-commands-run" title="永久链接至标题">¶</a></h2>
<section id="why-is-my-command-behaving-differently-under-invoke-versus-being-run-by-hand">
<span id="program-behavior-ptys"></span><h3>为什么我的命令在 Invoke 下的表现与手动运行的表现不同？<a class="headerlink" href="#why-is-my-command-behaving-differently-under-invoke-versus-being-run-by-hand" title="永久链接至标题">¶</a></h3>
<p>99% 的情况下，在你的 <code class="docutils literal notranslate"><span class="pre">run</span></code> 调用中加入 <code class="docutils literal notranslate"><span class="pre">pty=True</span></code> 会使事情如你所期望的那样运行。请继续阅读为什么会这样（以及为什么 <code class="docutils literal notranslate"><span class="pre">pty=True</span></code> 不是默认的）。</p>
<p>命令行程序经常根据控制终端是否存在而改变行为；一个常见的例子是使用或不使用彩色输出。当你的输出接收者是终端上的人时，你可能想使用颜色，调整行长以匹配终端宽度，等等。</p>
<p>相反，当你的输出被发送到另一个程序（shell 管道、CI 服务器、文件等）时，颜色转义代码和其他终端特有的行为会导致不必要的垃圾。</p>
<p>Invoke 的用例跨越了上述两种情况 – 有时你只想直接显示数据，有时你只想把它抓成一个字符串；往往你想两者兼得。正因为如此，对于伪终端的使用，没有任何默认行为 – 一些大块的用例无论如何都会带来不便。</p>
<p>对于不关心的用例，没有伪终端的直接调用更快、更干净，所以它是默认的。</p>
</section>
<section id="calling-python-or-python-scripts-prints-all-the-output-at-the-end-of-the-run">
<h3>调用 Python 或 Python 脚本在运行结束时打印出所有的输出！<a class="headerlink" href="#calling-python-or-python-scripts-prints-all-the-output-at-the-end-of-the-run" title="永久链接至标题">¶</a></h3>
<div class="admonition note">
<p class="admonition-title">备注</p>
<p>这通常只是 Python 3 下的一个问题。</p>
</div>
<p>症状很容易发现–你正在运行一个需要几秒钟或更长时间才能执行的命令，它通常会在执行过程中打印出几行文字，但通过 <code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code> 开始时似乎什么都没有发生，一旦执行完毕，所有的输出都会打印出来。</p>
<p>这通常是由于Python–你所调用的Python内部可执行程序，而不是Invoke运行的那个–对其输出流进行了不必要的缓冲。当它认为它是以非交互式方式被调用时，它就会这样做。</p>
<p>修复方法是通过说 <code class="docutils literal notranslate"><span class="pre">pty=True</span></code> 来强制 Invoke 在伪终端中运行命令（例如，<code class="docutils literal notranslate"><span class="pre">run(&quot;python</span> <span class="pre">foo&quot;,</span> <span class="pre">pty=True)</span></code>）。</p>
<p>另外，由于 Invoke 和内部命令都是 Python，你可以尝试在使用 Invoke 的代码中直接加载内部 Python 模块，并调用其命令行存根使用的任何方法–而不是使用 <code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code>。这通常也有其他好处。</p>
</section>
<section id="why-do-i-sometimes-see-err-stdin-is-not-a-tty">
<span id="stdin-not-tty"></span><h3>为什么我有时会看到 <code class="docutils literal notranslate"><span class="pre">err:</span> <span class="pre">stdin:</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">a</span> <span class="pre">tty</span></code> ？<a class="headerlink" href="#why-do-i-sometimes-see-err-stdin-is-not-a-tty" title="永久链接至标题">¶</a></h3>
<p>参见 <a class="reference internal" href="#program-behavior-ptys"><span class="std std-ref">为什么我的命令在 Invoke 下的表现与手动运行的表现不同？</span></a> – 同样的根本原因（默认缺乏 PTY）可能是怎么回事。在某些情况下（例如通过 Fabric 库），它的发生是因为 shell 的登录文件调用了需要 PTY 的程序（例如 <code class="docutils literal notranslate"><span class="pre">biff</span></code> 或 <code class="docutils literal notranslate"><span class="pre">mesg</span></code>），所以如果实际的前台命令似乎没有问题，请确保在那里查看。</p>
</section>
<section id="everything-just-exits-silently-after-i-run-a-command">
<h3>在我运行命令后，所有的东西都默默地退出了！<a class="headerlink" href="#everything-just-exits-silently-after-i-run-a-command" title="永久链接至标题">¶</a></h3>
<p>仔细检查命令的退出代码！默认情况下，在 <code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code> 调用结束时收到非零的退出代码将导致 Invoke 停止执行并以相同的代码退出。一些程序（pylint、Nagios 检查脚本等）使用退出代码来表示非致命状态，这可能会造成混淆。</p>
<p>这里的解决方案是在你的 <code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code> 调用中添加 <code class="docutils literal notranslate"><span class="pre">warn=True</span></code>，这将禁用自动退出行为。然后你可以手工检查结果的 <code class="docutils literal notranslate"><span class="pre">.exited</span></code> 属性，以确定它是否真的成功了。</p>
</section>
<section id="the-auto-responder-functionality-isn-t-working-for-my-password-prompts">
<h3>自动回复功能对我的密码提示不起作用！<a class="headerlink" href="#the-auto-responder-functionality-isn-t-working-for-my-password-prompts" title="永久链接至标题">¶</a></h3>
<p>有些程序将密码提示或其他输出直接写到本地终端（操作系统级的TTY设备），绕过了通常的 stdout/stderr 流。例如，这正是 <a class="reference external" href="https://docs.python.org/2.7/library/getpass.html#getpass.getpass" title="(在 Python v2.7)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stdlib</span> <span class="pre">的</span> <span class="pre">getpass</span> <span class="pre">模块</span></code></a> 所做的，如果你正在调用一个恰好用 Python 编写的程序的话。</p>
<p>当这种情况发生时，我们无能为力，因为我们所能看到的只是子进程的常规输出流。值得庆幸的是，解决方案通常很简单：只要在你的 <code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code> 调用中加入 <code class="docutils literal notranslate"><span class="pre">pty=True</span></code>。强制使用一个明确的伪终端，通常会诱使这类程序向 stderr 写入提示信息</p>
</section>
<section id="i-m-getting-ioerror-inappropriate-ioctl-for-device-when-i-run-commands">
<h3>当我运行命令时，我得到 <code class="docutils literal notranslate"><span class="pre">IOError:</span> <span class="pre">Inappropriate</span> <span class="pre">ioctl</span> <span class="pre">for</span> <span class="pre">device</span></code>！<a class="headerlink" href="#i-m-getting-ioerror-inappropriate-ioctl-for-device-when-i-run-commands" title="永久链接至标题">¶</a></h3>
<p>这个错误通常意味着你的项目或其依赖的某些代码用一个实际上没有连接到终端的对象（<code class="docutils literal notranslate"><span class="pre">sys.stdin</span></code>, <code class="docutils literal notranslate"><span class="pre">sys.stdout</span></code> 或 <code class="docutils literal notranslate"><span class="pre">sys.stderr</span></code>）替换了一个进程流，但它假装自己是终端。例如，测试运行程序或构建系统经常这样做”</p>
<p>99% 的时候，这只对 stdin 弹出，在这种情况下，你可以通过在 <code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code> 中指定 <code class="docutils literal notranslate"><span class="pre">in_stream=False</span></code> 来解决（注意：<code class="docutils literal notranslate"><span class="pre">False</span></code>，<a href="#id1"><span class="problematic" id="id2">**</span></a>不是 <code class="docutils literal notranslate"><span class="pre">None</span></code> ！）</p>
<section id="gory-details">
<h4>Gory 细节<a class="headerlink" href="#gory-details" title="永久链接至标题">¶</a></h4>
<p>从技术上讲，发生的事情是交给 Invoke 的命令执行器的对象，例如 <code class="docutils literal notranslate"><span class="pre">run('command',</span> <span class="pre">in_stream=xxx)</span></code> （或 <code class="docutils literal notranslate"><span class="pre">out_stream</span></code> 或等；这些都默认为上面列出的 <code class="docutils literal notranslate"><span class="pre">sys</span></code> 成员）实现了 <code class="docutils literal notranslate"><span class="pre">fileno</span></code> 方法，但没有返回真正终端文件描述符的 ID。以这种方式破坏合同是导致 Invoke 做操作系统不喜欢的事情的原因。</p>
<p>我们一直在努力使这个检测更加智能；如果升级到最新版本的 Invoke 还不能解决你的问题，请提交一份错误报告，包括关于 <code class="docutils literal notranslate"><span class="pre">sys.stdin/stdout/stderr</span></code> 的值和类型的细节。希望我们能找到另一个可以使用的启发式方法！</p>
</section>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Invoke</a></h1>



<p class="blurb">Pythonic task execution</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=pyinvoke&repo=invoke&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





    

<p>
<a class="badge" href="https://travis-ci.org/pyinvoke/invoke">
    <img
        alt="https://secure.travis-ci.org/pyinvoke/invoke.svg?branch=master"
        src="https://secure.travis-ci.org/pyinvoke/invoke.svg?branch=master"
    />
</a>
</p>




    

<p>
<a class="badge" href="https://codecov.io/github/pyinvoke/invoke">
    <img
    alt="https://codecov.io/github/pyinvoke/invoke/coverage.svg?branch=master"
    src="https://codecov.io/github/pyinvoke/invoke/coverage.svg?branch=master"
    />
</a>
</p>
<h3>导航</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">常见问题</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#general-project-questions">一般项目问题</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#why-was-invoke-split-off-from-the-fabric-project">为什么 Invoke 从 Fabric 项目中分离出来？</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#defining-executing-tasks">定义/执行任务</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#my-task-s-first-argument-isn-t-showing-up-in-help">我的任务的第一个参数没有显示在 <code class="docutils literal notranslate"><span class="pre">--help</span></code> 中！</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-command-line-says-my-task-s-first-argument-is-invalid">命令行说我的任务的第一个参数是无效的！</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#running-local-shell-commands-run">运行本地shell命令（<code class="docutils literal notranslate"><span class="pre">run</span></code>）</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#why-is-my-command-behaving-differently-under-invoke-versus-being-run-by-hand">为什么我的命令在 Invoke 下的表现与手动运行的表现不同？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#calling-python-or-python-scripts-prints-all-the-output-at-the-end-of-the-run">调用 Python 或 Python 脚本在运行结束时打印出所有的输出！</a></li>
<li class="toctree-l3"><a class="reference internal" href="#why-do-i-sometimes-see-err-stdin-is-not-a-tty">为什么我有时会看到 <code class="docutils literal notranslate"><span class="pre">err:</span> <span class="pre">stdin:</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">a</span> <span class="pre">tty</span></code> ？</a></li>
<li class="toctree-l3"><a class="reference internal" href="#everything-just-exits-silently-after-i-run-a-command">在我运行命令后，所有的东西都默默地退出了！</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-auto-responder-functionality-isn-t-working-for-my-password-prompts">自动回复功能对我的密码提示不起作用！</a></li>
<li class="toctree-l3"><a class="reference internal" href="#i-m-getting-ioerror-inappropriate-ioctl-for-device-when-i-run-commands">当我运行命令时，我得到 <code class="docutils literal notranslate"><span class="pre">IOError:</span> <span class="pre">Inappropriate</span> <span class="pre">ioctl</span> <span class="pre">for</span> <span class="pre">device</span></code>！</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#gory-details">Gory 细节</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="installing.html">安装</a></li>
<li class="toctree-l1"><a class="reference internal" href="development.html">开发</a></li>
<li class="toctree-l1"><a class="reference internal" href="prior-art.html">现有技术</a></li>
<li class="toctree-l1"><a class="reference internal" href="contact.html">Contact</a></li>
</ul>


<hr />
<ul>
    
    <li class="toctree-l1"><a href="https://daobook.github.io/invoke/docs">Documentation</a></li>
    
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">快速搜索</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="转向" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>


<h3 class="donation">Donate/support</h3>







<p>
Professionally-supported Invoke is available with the
<a href="https://tidelift.com/subscription/pkg/pypi-invoke?utm_source=pypi-invoke&utm_medium=referral&utm_campaign=docs">Tidelift Subscription</a>.
</p>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022 Jeff Forcier.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.4.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/faq.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-18486793-3']);
      _gaq.push(['_setDomainName', 'none']);
      _gaq.push(['_setAllowLinker', true]);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
    
  </body>
</html>